# Raft Consensus Algorithm — Cline Rules (v2)
# Governs how this codebase is built and maintained.

## 1. RAFT SPEC COMPLIANCE
- Every rule implemented MUST cite the paper section in a comment: `# §5.2`, `# §5.4.1`, etc.
- Reference: "In Search of an Understandable Consensus Algorithm" — Ongaro & Ousterhout (2014)
- Never implement a shortcut that violates a paper invariant, even for simplicity.

## 2. CRITICAL RAFT INVARIANTS (never violate these)
- Persistent state (currentTerm, votedFor, log) MUST be written to stable storage BEFORE
  responding to any RPC. Violation = data loss on crash.
- A server votes for at most ONE candidate per term.
- Leaders never overwrite or delete log entries — only append.
- A leader only commits entries from its current term (§5.4.2).
- commitIndex only moves forward, never backward.
- lastApplied only moves forward, never backward.

## 3. MODULE RESPONSIBILITIES (single responsibility principle)
- `RaftEx.Server`       → :gen_statem FSM, all Raft role logic (follower/candidate/leader)
- `RaftEx.Log`          → Log storage, retrieval, truncation (DETS-backed)
- `RaftEx.Persistence`  → currentTerm + votedFor persistence (DETS-backed)
- `RaftEx.RPC`          → Message structs (RequestVote, AppendEntries, InstallSnapshot)
- `RaftEx.StateMachine` → Application state machine (KV store), apply commands
- `RaftEx.Snapshot`     → Snapshot creation, storage, InstallSnapshot handling
- `RaftEx.Inspector`    → Event observer, prints all state transitions and RPCs
- `RaftEx.Cluster`      → Peer list management, quorum math
- `RaftEx`              → Public API (set/get/delete, cluster management)

## 4. OTP PATTERNS
- Use `:gen_statem` with `state_functions` callback mode for the Raft server.
  Each role is a named function: `follower/3`, `candidate/3`, `leader/3`.
- Timers: use `:gen_statem` built-in `{:state_timeout, ms, event}` for election timeout.
  Use `{:timeout, ms, event}` for heartbeat interval.
- Supervision: use `DynamicSupervisor` for spawning Raft nodes at runtime.
- All inter-node communication via `:gen_statem.cast/2` (fire-and-forget RPCs)
  and `:gen_statem.call/3` (client commands that need responses).

## 5. PERSISTENCE RULES
- DETS tables: one per node, named by node_id.
- Log entries stored as: `{index :: pos_integer(), term :: non_neg_integer(), command :: term()}`
- Metadata stored as: `{:current_term, integer()}` and `{:voted_for, term()}`
- Always call `RaftEx.Persistence.save_term/2` and `RaftEx.Persistence.save_vote/2`
  BEFORE sending any RPC response.

## 6. TIMING CONSTANTS
- Election timeout: random between 150ms and 300ms (§5.2)
- Heartbeat interval: 50ms (must be << election timeout)
- RPC timeout: 100ms (for call-based RPCs)

## 7. COMMIT DISCIPLINE
- Commit after each completed phase.
- Subject line: ≤ 72 chars, imperative mood, prefixed with feat/fix/test/refactor/docs
- Body: 2–4 bullet points, what changed and why.
- Never commit broken code. Run `mix compile` before committing.
- Tag each phase commit: `git tag phase-N-description`

## 8. TESTING RULES
- Every Raft invariant must have at least one ExUnit test.
- Use `StreamData` for property-based tests on log invariants.
- Test election with 3-node cluster (minimum for majority).
- Test log replication with leader crash mid-replication.
- Test snapshot install on a lagging follower.

## 9. OBSERVABILITY
- Every state transition emits a `:telemetry` event.
- Every RPC send/receive is logged via `RaftEx.Inspector`.
- Log format: `[NODE :id] [ROLE] event description`
- Inspector output goes to stdout so it's visible in the demo.

## 10. CODE QUALITY
- No `IO.puts` in library code — use `Logger` or `RaftEx.Inspector`.
- No bare `send/2` for Raft RPCs — always go through `RaftEx.RPC.send_rpc/3`.
- Pattern match exhaustively in :gen_statem callbacks.
- Use `@spec` typespecs for all public functions.
- Use `@moduledoc` and `@doc` for all public modules and functions.
- No line limit on source files. `.clinerules` itself must stay under 500 lines.
